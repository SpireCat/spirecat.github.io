---
layout: post
title: 使用Python实现有向图的路径搜索算法
date: 2015-12-2 14:22:10
categorise: 算法初步
permalink: /archivers/python_rout_search
---
<style type="text/css">
    .indent{
        text-indent:2em;
    }
</style>
<p class="indent">掌握一门高级语言的标准绝不是多知道几个API而已，那只是一个必要非充分条件。</p>
<p class="indent">虽然开门见山是自打小学起就被语文老师赞许的作文手段，但是为了充分尊重处女座以及尚未被好奇心害死的猫们，我还是简单叙述一下原委。如果你是单纯奔着算法来的，略过此段剩余88个字。算法是由于现在做的一个恶意APP判别的项目的其中一步重要工作是根据依靠Flowdroid对APK文件进行静态分析得到的dot图找到任意一个Sink点通往入度为0的节点的所有路径。</p>
<p class="indent">本算法目的在于，基于某个已知的单向含环有向图，找到图中任意一个节点上行至所有可达的入度为0的节点的全部路径。</p>
<p class="indent">当然，除了算法本身的意义之外，更多的意义是通过算法窥探一些Python这门面向对象语言的底层结构，这也就是开篇第一段的深意所在。</p>
<p class="indent">在算法设计之初我们已经get到的是图中的每一条边，这些边被存入在dot文件中（如图[1]所示）。在这里，对于节点A指向节点B的一条边，我们定义A为前点，B为后点。首先我们需要对这样的一个文件进行处理：1.将所有具有相同后点的前点放入同一个列表（我们称其为前点字典）内，并在列表的头位置放入后点；2.将所有的前点和后点区分，分别放入两个不同的集合中；3.找到所有入度为0的节点放入一个列表内，即在前点集合中存在但在后点集合中不存在的点。</p>
<p><img src="/image/2015120301.jpg" /></p>
<p align="center"><small>图 [1]</small></p>
<p class="indent">算法的本身是基于深度优先的算法设计的，但是略有不同。大体思想为，首先将起点压入栈中，然后取出栈顶元素的前点集的首个元素压入栈中，一直执行到栈顶元素的前点集为空位置（此时前点集一定在0入度集中），此时打印输出栈。然后将栈顶元素弹出，直到栈顶元素的前点集不为空为止。再次取出前点集的首个元素压栈，以此类推，直到起点也从栈中被弹出为止。当然，这中间还有许多细节需要细细去分析，一会儿会贴出源码，所以我也就没有必要在这里赘述。下面讲的是这个算法中的闪光点：</p>
<p class="indent">1.将算法更好地融入到Python中。众所周知，Python不像Java一样，把堆栈类封装好让你体验Sun公司的伟大，Python只有列表list供你使用，然而这对我们来说就足够了，我们利用对于二维列表的限定操作来实现整个的算法工作。在压栈时，我们把要被压栈的元素连同它的整个前点集（这个思想试用于不含环的图中，当处理含环的图时将会被推翻）作为一个完整的列表压入作为栈的列表中。这样做的好处是我们既可以省去构造堆栈结构的工作又可以轻松在堆栈列表中得出在进行回溯时哪些前点是被访问过的而哪些前点是未被访问过的，当然缺点是你在处理堆栈时需要思维足够清晰才能保证不出错。记住：一旦压栈，压栈元素+整个前点集全部入站！为了更好的解释这件事情，我做了一个图用来更好的展示栈的内容变化（如图[2]所示）。</p>
<p><img src="/image/2015120302.jpg" /></p>
<p align="center"><small>图 [2]</small></p>
<p class="indent">当我们把前点集一同压入栈中时，需要从前点字典中找到相应的前点集。那么问题随即就到来了，当我们执行append()函数操作之后，对栈顶元素的集合进行操作时，会发现前点字典也会发生相应的变化。实际上起初我并没有发现这个很严重的问题，但是当我察觉一个包含上千个点的图中，某一个由底层节点出发的路径还不超过五十条时，我知道BUG是存在的。其实错误犯得很严重，因为我根本没有察觉到Python是不支持直接的引用参数传递的，Python传递的只是引用。我想与其我解释半天什么是传参什么是传引用也没有意义，不管你对C中的指针有没有概念，然而图[3]的实例可以帮助你解决这个问题。知道了问题是什么，事情也就解决了一半，虽然这两半各耗费了我两个小时的时间。晚上去球场打了会儿球回来灵机一动，解决办法找到了：实例化一个列表fake，将要append()的内容放入列表中，然后再进行后续操作，就不会对原有的前点字典产生影响。也就是说，fake只是一个傀儡。然而，这些都不重要，重要的是我打球蹬着一双滑板鞋穿着一条小脚牛仔裤毫无悬念的------被------虐------了！:-)</p>
<p><img src="/image/2015120303.jpg" /></p>
<p align="center"><small>图 [3]</small></p>
<p class="indent">2.如何解决含环的图结构？实话说这个还是有一定的技术含量的，当对整个压栈过程了如指掌时，我们可以发现，无论是否含有环的结构，任何一条路径在遍历是都只能走过一次图中的任意一条边。简单来说，也就是单向图的结构不存在重复遍历的边。那么，结合上文中埋下的伏笔，当我们进行压栈时，就不能把压栈元素的所有前点集全部压入堆栈中，而是需要排除掉那些已经压入堆栈的边中的前点。虽然在程序中实现只是一条if语句，但是需要关注的是整个含环图中的回溯思想。为了更好的展示算法，我做了一个简化模型，图结构如图[4]所示。图[4]后面是简化模型的Python源码，之后的图[5]是运行结果。</p>
<p><img src="/image/2015120304.jpg" /></p>
<p align="center"><small>图 [4]</small></p>
<code><pre>mylist=[[1,2]]
lenth=1
count=1
supers=[[1,2],[2,3,5],[3,4,6],[4,2],[6,7],[7,3]]
starts=[5]
while mylist:
    print "--",mylist
    toplen=len(mylist[lenth-1])
    t=lenth
    zhan=[]
    for item in mylist:
        zhan.append(item[0])
    if toplen>1:
        temp=mylist[lenth-1][1]
        del(mylist[lenth-1][1])            
        excepts=[]
        for item in zhan:
            if temp==item:
                excepts.append(zhan[zhan.index(item)+1])
        for su in supers:
            if su[0]==temp:
                ss=[]
                for item in su:
                    if item not in excepts:
                        ss.append(item)
                mylist.append(ss)
                lenth+=1
        if t==lenth:
            mylist.append([temp])
            lenth+=1
    else:
        if mylist[lenth-1][0] in starts:
            print "Rout NO.",count
            count+=1
            for item in mylist:
                print item[0]
            del(mylist[lenth-1])
            lenth-=1
        else:
            del(mylist[lenth-1])
            lenth-=1
print "-------------------------------------------"
</pre></code>
<p><img src="/image/2015120305.jpg" /></p>
<p align="center"><small>图 [5]</small></p>
<p class="indent">实际上到这里该BB的都已经BB得差不多了。但是为了升华主题，正好也是回答了之前有个朋友问我的一句话，他问“你和吴彦祖哪个更帅一些”，我的答案是“番茄与西红柿马铃薯与土豆吴彦祖与我”。</p>
<p class="indent"><small>转载文章请注明出自“Spirecat's Blog（spirecat.github.io）”。分享至上，内容拒绝商业用途。</small></p>