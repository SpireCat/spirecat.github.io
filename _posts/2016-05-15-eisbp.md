---
layout: post
title:  "堆栈中的EIP,ESP,EBP"
date:   2016-5-15 18:00
categories: 逆向工程
permalink: /archivers/eisbp
---

# 栈和栈指针

&#160; &#160; &#160; &#160;对于学习过汇编语言的同学都知道，EIP，ESP，EBP都是系统中的寄存器，里面存放的都是地址信息。对于这三个寄存器：

 - EIP寄存器：存储CPU下次要执行的指令的地址

 - ESP寄存器：存储栈顶指针

 - EBP寄存器：存储栈底指针

&#160; &#160; &#160; &#160;在栈结构中，每4字节的栈空间保存一个数据，像这样的栈顶到栈底之间的存储空间被称为栈帧。那么形成栈帧的条件也就不难推测了：当栈顶指针ESP小于栈底指针EBP时，就形成了栈帧。通常，栈帧中可以寻址的数据有局部变量、函数返回地址、函数参数等。

&#160; &#160; &#160; &#160;不同的两次函数调用，所形成的栈帧也不同。当由一个函数进入到另一个函数中时，就会针对调用的函数开辟出其所需要的栈空间，形成此函数的栈帧。当这个函数结束调用时，需要清理掉它所使用的栈空间，关闭栈帧，这一过程也称作栈平衡。Warning：如果某一个函数在开辟了新的栈空间后没有进行恢复，或者过度恢复，那么将会造成栈空间的上溢或者下溢！

# 代码实例
```c
void func()
{
	println("Spire");
}
void main()
{
	func();
	println("Cat");
}
```
&#160; &#160; &#160; &#160;我们使用上面这段代码的执行过程结合栈指针来解释。

&#160; &#160; &#160; &#160;首先，在主入口处调用了函数func()。在调用func()之前，ESP寄存器中存储既是栈顶指针，也是栈底指针。ESP将存储的地址传递给EBP寄存器，并且在后面的执行过程中，ESP始终指向栈顶。在func()执行完成后，CPU跳转到EIP存储的地址中去。EIP寄存器存储的是CPU将要执行的下一条指令的地址，也就是说，在这个例子中，EIP存储的是"println("Cat");"这条语句的地址。并且，当func()执行完成后，EBP将地址传递给ESP，这样ESP又一次指向了栈底的地址。

